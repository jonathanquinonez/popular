package com.popular.android.mibanco.task;

import android.content.Context;

import androidx.annotation.Nullable;

import com.popular.android.mibanco.App;
import com.popular.android.mibanco.MiBancoConstants;
import com.popular.android.mibanco.R;
import com.popular.android.mibanco.exception.AccessBlockedException;
import com.popular.android.mibanco.listener.ResponderListener;
import com.popular.android.mibanco.model.RSAChallengeResponse;
import com.popular.android.mibanco.model.RsaModResponse;
import com.popular.android.mibanco.util.BPAnalytics;
import com.popular.android.mibanco.util.Utils;

public class RSAChallengeTasks {

    private static abstract class RSAChallengeTask<T> extends SessionAsyncTask {

        protected T response;

        public RSAChallengeTask(Context context, ResponderListener listener) {
            super(context, listener, true);
        }

        @Override
        protected Integer doInBackground(Object... params) {
            try {
                response = doAsync();
                return RESULT_SUCCESS;
            } catch (final Exception e) {
                taskException = e;
                return RESULT_FAILURE;
            }
        }

        @Override
        protected void onPostExecute(Integer result) {
            super.onPostExecute(result);
            if (result == RESULT_SUCCESS && taskListener != null) {
                ((ResponderListener) taskListener).responder(responderName, response);
            }
        }

        protected abstract T doAsync() throws Exception;
    }

    /**
     * get RSA challenge Status and type.
     *
     * @param context      the context
     * @param listener     the listener
     */
    public static void getRSAChallenge(final Context context, final ResponderListener listener) {
        new RSAChallengeStatusTasks(context, listener).execute();
    }

    /**
     * get RSA challenge Status and type.
     *
     * @param context      the context
     * @param sdkRsaJson   the sdkRsaJson
     * @param listener     the listener
     */
    public static void getRSAChallenge(final Context context, final String sdkRsaJson,
                                       final String rsaCookie, final ResponderListener listener) {
        new RSAChallengeStatusTasks(context, sdkRsaJson, rsaCookie, listener).execute();
    }


    /**
     * Fetches RSA challenge Status.
     */
    private static class RSAChallengeStatusTasks extends RSAChallengeTask<RSAChallengeResponse> {

        /**
         * sdkRsaJson SDK RSA Generated by Mobile
         */
        private String mSdkRsaJson = "";

        /**
         * Cookie RSA Generated by Mobile
         */
        private String mRsaCookie = "";

        /**
         * Instantiates a new RSAChallengeStatusTasks.
         *
         * @param context      the context
         * @param listener     the listener
         */
        public RSAChallengeStatusTasks(final Context context, final ResponderListener listener) {
            super(context, listener);
        }

        /**
         * Instantiates a new RSAChallengeStatusTasks.
         *
         * @param context      the context
         * @param sdkRsaJson      the sdkRsaJson
         * @param listener     the listener
         */
        RSAChallengeStatusTasks(final Context context, final String sdkRsaJson, final String rsaCookie,
                                       final ResponderListener listener) {
            super(context, listener);
            this.mSdkRsaJson = sdkRsaJson;
            this.mRsaCookie = rsaCookie;
        }

        protected RSAChallengeResponse doAsync() throws Exception  {
            response = App.getApplicationInstance().getApiClient().getRSAChallenge(mSdkRsaJson, mRsaCookie);

            Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, "", context);
            if (response.getRsaCookie() != null && !response.getRsaCookie().equals("")) {
                Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, response.getRsaCookie(), context);
            }

            responderName = response.getResponderName();
            if (responderName.equalsIgnoreCase("login")) {
                if (response.isAccessBlocked()) {
                    BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
                } else {
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.session_has_expired), true);
                }
            } else if (!responderName.equalsIgnoreCase("mobileCheckRsaChallenge")) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            }
            return response;
        }
    }




    /**
     * Post RSA Question Answer.
     *
     * @param context      the context
     * @param listener     the listener
     * @param answer       the answer to the question
     */
    public static void postRSAChallengeAnswer(final Context context, final String answer, final String sdkRsaJson, final String rsaCookie,
                                              final ResponderListener listener) {
        new RSAAnswerChallengeTask(context, answer, sdkRsaJson, rsaCookie, listener).execute();
    }

    /**
     * Fetches transfer history from the web service.
     */
    private static class RSAAnswerChallengeTask extends RSAChallengeTask<RSAChallengeResponse> {

        /**
         * Transfer history object.
         */

        private String mAnswer;

        /**
         * sdkRsaJson SDK RSA Generated by Mobile
         */
        private String mSdkRsaJson = "";

        /**
         * Cookie RSA Generated by Mobile
         */
        private String mRsaCookie = "";

        /**
         * Instantiates a new FetchTransferHistoryTask.
         *
         * @param context      the context
         * @param listener     the listener
         */
        RSAAnswerChallengeTask(final Context context, final String answer, final String sdkRsaJson, final String rsaCookie,
                                      final ResponderListener listener) {
            super(context, listener);
            mAnswer = answer;

            this.mSdkRsaJson = sdkRsaJson;
            this.mRsaCookie = rsaCookie;
        }

        @Override
        protected RSAChallengeResponse doAsync() throws Exception {
            response = App.getApplicationInstance().getApiClient().postRSAAnswerChallenge(mAnswer, mSdkRsaJson, mRsaCookie);

            Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, "", context);
            if (response.getRsaCookie() != null && !response.getRsaCookie().equals("")) {
                Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, response.getRsaCookie(), context);
            }

            responderName = response.getResponderName();
            if (response.isRSABloked()) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            } else if (responderName.equalsIgnoreCase("login")) {
                if (response.isAccessBlocked()) {
                    BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
                } else {
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.session_has_expired), true);
                }
            } else if (!responderName.equalsIgnoreCase("mobileCheckRsaChallenge")) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            }
            return response;
        }
    }


    /**
     * get RSA challenge Status and type.
     *
     * @param context      the context
     * @param listener     the listener
     */
    public static void getOOBChallenge(final Context context, final String sdkRsaJson, final String rsaCookie,
                                       final ResponderListener listener) {
        new OOBChallengeInfoTasks(context, sdkRsaJson, rsaCookie, listener).execute();
    }

    /**
     * Fetches RSA challenge Status.
     */
    private static class OOBChallengeInfoTasks extends RSAChallengeTask<RSAChallengeResponse> {

        /**
         * Mobile SDK Data.
         */
        private String mSdkRsaJson;

        /**
         * Mobile SDK Data.
         */
        private String mRsaCookie;

        /**
         * Instantiates a new RSAChallengeStatusTasks.
         *
         * @param context      the context
         * @param listener     the listener
         */
        OOBChallengeInfoTasks(final Context context, final String sdkRsaJson, final String rsaCookie,
                                     final ResponderListener listener) {
            super(context, listener);
            this.mSdkRsaJson = sdkRsaJson;
            this.mRsaCookie = rsaCookie;
        }

        protected RSAChallengeResponse doAsync() throws Exception  {
            response = App.getApplicationInstance().getApiClient().getOOBChallenge(mSdkRsaJson, mRsaCookie);

            Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, "", context);
            if (response.getRsaCookie() != null && !response.getRsaCookie().equals("")) {
                Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, response.getRsaCookie(), context);
            }

            responderName = response.getResponderName();
            if (response.isRSABloked()) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            } else if (responderName.equalsIgnoreCase("login")) {
                if (response.isAccessBlocked()) {
                    BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
                } else {
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.session_has_expired), true);
                }
            } else if (!responderName.equalsIgnoreCase(MiBancoConstants.OOB_ACTION_NAME)) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            }

            return response;
        }
    }

    /**
     * Post RSA Question Answer.
     *
     * @param context       the context
     * @param listener      the listener
     * @param code          the code received by sms
     */
    public static void postOOBCodeAnswer(final Context context, @Nullable final String code, @Nullable final String target, final String type, final ResponderListener listener) {
        new OOBAnswerCodeTask(context, code, target, type, listener).execute();
    }

    /**
     * Fetches transfer history from the web service.
     */
    private static class OOBAnswerCodeTask extends RSAChallengeTask<RSAChallengeResponse> {

        /**
         * OOB code.
         */

        private String mCode;

        /**
         * OOB mTarget.
         */

        private String mTarget;

        /**
         * OOB actionType.
         */

        private String actionType;

        /**
         * Instantiates a new OOBAnswerCodeTask.
         *
         * @param context      the context
         * @param listener     the listener
         */
        public OOBAnswerCodeTask(final Context context, @Nullable final String code, @Nullable final String target, String type, final ResponderListener listener) {
            super(context, listener);
            mCode = code;
            actionType = type;
            mTarget = target;
        }

        @Override
        protected RSAChallengeResponse doAsync() throws Exception  {
            switch (actionType) {
                case MiBancoConstants.OOB_VALIDATE_SMSCODE:
                    response = App.getApplicationInstance().getApiClient().postOOBChallenge(actionType, mCode, true, mTarget);
                    break;
                case MiBancoConstants.OOB_SEND_SMSCODE:
                    response = App.getApplicationInstance().getApiClient().postOOBChallenge(actionType, mCode, false, mTarget);
                    break;
                case MiBancoConstants.OOB_SEND_ALT_PHONE:
                    response = App.getApplicationInstance().getApiClient().postOOBChallenge(MiBancoConstants.OOB_NO_PHONE, mCode, false, mTarget);
                    break;
                case MiBancoConstants.OOB_VALIDATE_CALLCODE:
                    response = App.getApplicationInstance().getApiClient().postOOBChallenge(actionType, mCode, true, mTarget);
                    break;
                case MiBancoConstants.OOB_CALL_PHONE:
                    response = App.getApplicationInstance().getApiClient().postOOBChallenge(actionType, mCode, false, mTarget);
                    break;
                case MiBancoConstants.OOB_CALL_ALT_PHONE:
                    response = App.getApplicationInstance().getApiClient().postOOBChallenge(actionType, mCode, false, mTarget);
                    break;
                default:
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.invalid_action), true);
            }

            Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, "", context);
            if (response.getRsaCookie() != null && !response.getRsaCookie().equals("")) {
                Utils.setPrefsString(MiBancoConstants.RSA_COOKIE, response.getRsaCookie(), context);
            }

            responderName = response.getResponderName();
            if (response.isRSABloked()) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            } else if (responderName.equalsIgnoreCase("login")) {
                if (response.isAccessBlocked()) {
                    BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
                } else {
                    throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.session_has_expired), true);
                }
            } else if (!responderName.equalsIgnoreCase(MiBancoConstants.OOB_ACTION_NAME)) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            }
            return response;
        }
    }

    /**
     * get RSA Status.
     *
     * @param context      the context
     * @param listener     the listener
     */
    public static void getRSAStatus(final Context context, final ResponderListener listener) {
        new RSAStatusTasks(context, listener).execute();
    }

    /**
     * Fetches RSA challenge Status.
     */
    private static class RSAStatusTasks extends RSAChallengeTask<RsaModResponse> {

        /**
         * Instantiates a new RSAChallengeStatusTasks.
         *
         * @param context      the context
         * @param listener     the listener
         */
        public RSAStatusTasks(final Context context, final ResponderListener listener) {
            super(context, listener);
        }

        protected RsaModResponse doAsync() throws Exception  {
            response = App.getApplicationInstance().getApiClient().rsaCheckStatus();

            responderName = response.getResponderName();
            if (responderName.equalsIgnoreCase("login")) {
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.session_has_expired), true);
            } else if (!responderName.equalsIgnoreCase("rsaCheckStatus")) {
                BPAnalytics.logEvent(BPAnalytics.EVENT_RSA_SESSION_BLOCKED);
                throw new AccessBlockedException(App.getApplicationInstance().getString(R.string.account_blocked_title), true);
            }
            return response;
        }
    }

}
